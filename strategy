PROGRAM -> STATEMENT
STATEMENT -> EXPRESSION_STMT | COMPOUND_STATEMENT | WHILE_STMT
COMPOUND_STATEMENT -> { STATEMENT_LIST }
STATEMENT_LIST -> STATEMENT_LIST STATEMENT | <empty>
EXPRESSION_STMT -> EXPRESSION;
WHILE_STMT -> WHILE ( EXPRESSION ) STATEMENT
EXPRESSION -> VAR = EXPRESSION | COMP_EXP
COMP_EXP -> E RELOP E | E
RELOP -> <= | < | == | != | > | >=
E -> E ADDOP T | T
ADDOP -> + | -
T -> FACTOR
FACTOR -> ( EXPRESSION ) | VAR
VAR -> ID

TreeNode E( ) {
    TreeNode t = T(  );
    while (IsAddOp (currentToken)) {
        TreeNode t1 = new TreeNode();
        t1.token = currentToken;
        getNextToken();
        t1.leftChild = t;
        t1.rightChild = T();
        t = t1;
    }
    return t;
}

gradually add in the expressions, then the rest of the statements, 
then variable declarations, then function declarations, and so 
forth.  Try to keep the parser in a working state.  Be thorough 
about checking and debugging each addition.  
Each time you add a new rule to the grammar you 
are parsing, you need to add a new kind of tree 
node to hold the data for that rule.

WHILE_STMT -> while ( EXPRESSION  ) STATEMENT
For this you need a tree node that I call a 
While_Node.  It  has two children: one that holds 
the condition (returned by EXPRESSION()) and one 
that holds the body (returned by STATEMENT()).

declaration node, e.g., has a next pointer
program in bpl is a list of declarations, so all DEC
nodes have next field
VAR_DEC, FUN_DEC, ARRAY_DEC

var dec needs string for name, string or token for type
boolean isPointer

fun dec needs string for name, token or string for
return type (int, void, or string)
DEC node for params
compound statement node for the body

array dec subclasses var dec and adds an integer for size

expressions also all have a next field
(actually, next can be part of TreeNode)
INT_VALUE (int literal)
STRING_VALUE (string literal)
VARIABLE (a var)
FUN_CALL
READ_EXP
ADDRESS_EXP
DEREF_EXP

if ( myScanner.nextToken.kind != T_WHILE) 
    throw new ParserException(myScanner.currentToken.lineNumber,
        "Bad while statement);
else {
    getNextToken();
    if ( myScanner.currentToken.kind != T_LPAREN)
        throw new ParserException ( myScanner.nextToken.lineNumber,
            "missing left parenthesis");
    else { 
        getNextToken();
        ExpressionNode e = Expression();
        ...
    }

}")

expect( int tokenKind, String message );
